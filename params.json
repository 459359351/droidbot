{"name":"Droidbot","tagline":"Automatic testing of apps in Droidbox.","body":"# droidbot\r\n\r\n## About\r\nA robot which automatically interacts with app in Droidbox.\r\n\r\ndroidbot sends keyevent, gestures and simulates system events \r\nin order to exploit more app states automatically.\r\ndroidbot decides which actions to take based on static analysis result of app \r\nand dynamic device information (view hierarchy).\r\n\r\n## Introduction\r\ndroidbot mainly does following two things:\r\n\r\n1. Setting up device environments, include the contacts, SMS logs, \r\ncall logs, GPS mocking, etc. The target app may have access to these resources, thus we \r\nprepare them before starting the app.\r\n\r\n    Multiple env policies can be used for setting up environments. Currently we support:\r\n\r\n    + `none` policy which does not set up any environment;\r\n    + `dummy` policy which just mocks same basic environment for all apps;\r\n\r\n    Later I am going to add more policies includes:\r\n\r\n    + `static` (to do) policy which set up environment according to static information of app,\r\n    for example permissions and files which the app have access to;\r\n    + `file` (to do) policy which read environment configurations from a json file.\r\n\r\n2. Sending events during the app is running. Events includes touch, drag gestures on screen, \r\nkeyevents, and simulated broadcasts, etc.\r\n\r\n    Similarly, we have several policies to produce events:\r\n    \r\n    + `none` policy which does not do anything;\r\n    + `monkey` policy which make use of adb `monkey` tool, to produce randomized events;\r\n    + `static` (to do) policy produces a list of events based on static information of app. Eg. \r\n    the intent-filters of each app.\r\n    + `dynamic` (to do) policy. It is actually the real human-like policy. It monitors the device \r\n    states, including the running activities, the foreground window, and the hierarchy of current \r\n    window and sends events according to these information.\r\n    It avoids going to same state too many times by comparing the window hierarchies, and \r\n    it sends activity-specific intents based on static analysis of app.\r\n    + `file` (to do) policy which generates events from a json file.\r\n\r\nMoreover, to evaluate whether our bot exploit more app states, I plan to implement a \r\nAndroid test coverage tool **without source code**. \r\n(note that `Emma` can evaluate coverage with source code)\r\nAndroid's `traceviewer` is able to record entering and exiting of each method, and we can get a list\r\nof all methods of app via reverse engineering. By comparing `traceviewer` log and app dex, hopefully \r\nwe can get the method coverage of app. The challenge is, `traceviewer` brings too much overhead, because \r\nit records much information we don't need.\r\n\r\n## Prerequisite\r\n\r\n1. `Java` version `1.6+`\r\n2. `Python` version `2.7`\r\n3. `Android SDK`, and `platform_tools` and `tools` added to `PATH`\r\n4. `Droidbox` version `4.1.1`\r\n\r\n## Installation\r\n\r\nClone this repo and cd to the directory.\r\n\r\nRun:\r\n\r\n```shell\r\npython setup.py install\r\n```\r\n\r\n## Usage\r\n\r\n1. Run `droidbox`, and install target app.\r\n2. Start droidbot:\r\n`python droidbot.py -h`\r\n\r\n## Evaluation\r\n\r\nDroidbot is evaluated by comparing with droidbox default mode (which does nothing) \r\nand adb monkey tool. The results are in [result](/evaluate_results/README.md).\r\n\r\n## Acknowledgement\r\n\r\n1. [AndroidViewClient](https://github.com/dtmilano/AndroidViewClient) \r\nis an amazing tool simplifies test script creation providing higher level operations \r\nand the ability of obtaining the tree of Views present at any given moment on the device \r\nor emulator screen.\r\n2. [Androguard](http://code.google.com/p/androguard/)\r\nis well-known for reverse-engineering of Android Apks.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}